#### prompt 12 - concrete endpoint implementations ####
'''
make the placeholder implementations for api.app endpoints concrete as following:
- create_conversation will create a new instance of session object with session service using the “hard_coded_user-01” as the user id and APP_NAME from config, and use id and last_update_time from Session object to return new Conversation object
- get_conversations will fetch all session objects from session service for "hard_coded_user-01" as user id and APP_NAME from config and return back the list of sessions as an array of Conversation objects
- send_message will use conversation_id, "hard_coded_user-01" and APP_NAME to get Session object from session service and then call the invoke method on runner for returning back Message
- get_conversation_history will use conversation_id, "hard_coded_user-01" and APP_NAME to get Session object from session service and return back list of events from the “history” of the session object.
- delete_conversation will use conversation_id, "hard_coded_user-01" and APP_NAME to call delete_session method on session service
'''

#### prompt 11 - wire up services and apps ####
'''
- modify api.app as following:
  - modify get_fast_api_app method to take parameters for runner: services.runner.Runner, session_service: BaseSessionService, memory_service: BaseMemoryService, artifact_service: BaseArtifactService, config: Config
  - references to these parameters should be saved for use in endpoint methods later
- update main.py as following:
  - initialize variables for session service, memory service, artifact service and root agent from services.provider module
  - initialize variables for services.runner.Runner instance
  - use the modified get_fast_api_app method with all appropriate parameters
'''


#### prompt 10 - fixing invoke method ####
'''
re-implement the invoke method to use corred ADK specific logic using below sample code as an example:
```
  # Prepare the user's message in ADK format
  content = types.Content(role='user', parts=[types.Part(text=query)])

  final_response_text = "Agent did not produce a final response." # Default

  # Key Concept: run_async executes the agent logic and yields Events.
  # We iterate through events to find the final answer.
  async for event in runner.run_async(user_id=user_id, session_id=session_id, new_message=content):
      # You can uncomment the line below to see *all* events during execution
      # print(f"  [Event] Author: {event.author}, Type: {type(event).__name__}, Final: {event.is_final_response()}, Content: {event.content}")

      # Key Concept: is_final_response() marks the concluding message for the turn.
      if event.is_final_response():
          if event.content and event.content.parts:
             # Assuming text response in the first part
             final_response_text = event.content.parts[0].text
          elif event.actions and event.actions.escalate: # Handle potential errors/escalations
             final_response_text = f"Agent escalated: {event.error_message or 'No specific message.'}"
          # Add more checks here if needed (e.g., specific error codes)
          break # Stop processing events once the final response is found

  print(f"<<< Agent Response: {final_response_text}")
```
for example:
- Message object needs to be changed to types.Content
- ADK runner's run_async need to be looped for events and processed appropriately
- only the final response event should be used to construct return Message
'''


##### prompt 9 - add runner factory ####
'''
add a submodule runner.py under backend/services and implement class Runner as following:
- constructor initializes with parameters root_agent: BaseAgent, session_service: BaseSessionService, memory_service: BaseMemoryService, artifact_service: BaseArtifactService, config: Config
- implements an async method invoke as following:
  - takes input parameters session: google.adk.sessions.Session, msg: api.models.Message and return back Message
  - The method will instantiate a new google.adk.runners.Runner using the parameters from class instance variables and execute the “run_async” method on the runner using the “user_id” and “id” of the Session object and "text" of the msg object from the method parameter
  - The method will return the agent’s final response as a new Message object. If the agent returns a structured output, that output will be a JSON string conforming to the schema as part of the agent's contract with clients. Runner will be oblivious of any such contract, and will simply pass back the response as a string.
'''

##### prompt 8 - add artifact service provider ####
'''
update backend/services/provider.py to implement method get_artifact_service that will do the following:
- takes input parameter config: Config
- returns an instance of BaseArtifactService from google.adk.artifacts module
- will create / initialize a singleton instance of artifacts service using below logic:
  - If config variable IS_TESTING is set, then return back instance of google.adk.artifacts.InMemoryArtifactService
  - else if config variable GCS_BUCKET is set and able to connect then return back instance of google.adk.artifacts.GcsArtifactService using GCS_BUCKET parameter
  - else fallback and return back instance of InMemoryArtifactService
'''


##### prompt 7 - add memory service provider ####
'''
update backend/services/provider.py to implement method get_memory_service that will do the following:
- takes input parameter config: Config
- returns an instance of BaseMemoryService from google.adk.memory module
- will create / initialize a singleton instance of memory service using below logic:
  - If config variable “IS_TESTING” is set, then return back instance of google.adk.memory.InMemoryMemoryService
  - else if able to connect then return back instance of google.adk.memory.VertexAiRagMemoryService with default parameters
  - else fallback and return back instance of InMemoryMemoryService
'''


##### prompt 6 - add session service provider ####
'''
update backend/services/provider.py to implement method get_session_service that will do the following:
- takes input parameter config: Config
- returns an instance of BaseSessionService from google.adk.sessions module
- will create / initialize a singleton instance of session service using below logic:
  - If config variable “IS_TESTING” is set, then return back instance of google.adk.sessions.InMemorySessionService
  - else if config variable “DB_URL” is set and able to connect, then return back instance of google.adk.sessions.DatabaseSessionService using DB_URL from config
  - else if config variable “DB_URL” is NOT set and able to connect then return back instance of google.adk.sessions.VertexAiSessionService using PROJECT_ID and LOCATION from config
  - else fallback and return back instance of InMemorySessionService
'''


##### prompt 5 - add root agent provider ####
'''
add a submodule provider.py under backend/services and implement method get_root_agent that will do the following:
- takes input parameter config: Config
- returns an instance of BaseAgent
- will create/initialize a singleton reference for root_agent from simple_agent.agent module
- will use the singleton reference in return value
''' 

##### prompt 4 - modify Dockerfile for FastAPI service #####
'''
Modify backend/Dockerfile for following:
- no need to inject environment variables, they will be injected during deployment
- add copying of following additional application code:
  - copy main.py
  - copy api/ directory
- modify startup to use command ["sh", "-c", "uvicorn main:app --host 0.0.0.0 --port $PORT"]

Modify backend/cloudbuild.yaml to use --ser-env-vars in run deploy command for following environment variables:
- export PROJECT_ID=$GOOGLE_CLOUD_PROJECT
- export LOCATION=$GOOGLE_CLOUD_LOCATION
- export USE_VERTEXAI=$GOOGLE_GENAI_USE_VERTEXAI
- export APP_NAME=$GOOGLE_ADK_APP_NAME
- export CORS_ORIGINS='["http://localhost:3000", "$FIREBASE_APP_URL"]'
- export IS_TESTING=false
- export DECKOFCARDS_URL="https://deckofcardsapi.com/api/deck"
- export FIREBASE_KEY_JSON="{}"

Modify Makefile to pass the appropriate arguments for deploy-backend target
'''

##### prompt 3 - create placeholder main app for FastAPI server #####
'''
Create a new main.py file under backend directory to do the following:
- get an instance of Config from utils.config module
- get an instance of FastAPI app from api.app module
- run the FastAPI app when execution is as __main__
- also make sure that FastAPI app can be run from command line using uvicorn directly
'''


##### prompt 2 - create placeholder endpoints without authN/authZ #####
Modify api/app.py for following:

- add new model class Conversation with following fields:
  - conv_id: str # ID of session object created by session service
  - updated_at: datetime # last_updated_time of session object

- add create_conversation to handle POST /conversations and return back an instance of Conversation object

- add get_conversations to handle GET /conversations and return back a list of Conversation objects

- add new model class Message with following fields:
  - text: str # always required and should be sent in new message request

- add send_message to handle POST /conversations/{coonversation_id}/messages and return back instance of Message object

- add get_conversation_history to handle GET /conversations/{conversation_id}/history and return back list of Event objects imported from google.adk.events

- add delete_conversation to handle DELETE /conversations/{conversation_id} and return 204 no content

##### prompt 1 - create placeholder FastAPI App Provider #####
- create a new submodule api.app under backend directory
- implement a method `get_fast_api_app` that takes parameter `config: Config` (from utils.config.Config) and returns back an instance of FastAPI
- the method will initialize and return a singleton instance of FastAPI app
- use a brief name for instance variable, example "_app"
- in app initialization use cors middleware with allow origins from config.CORS_ORIGINS
